{"ast":null,"code":"import axios from 'axios';\nimport { getToken } from './auth';\nexport const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n\n// Create axios instance with default config\nconst api = axios.create({\n  baseURL: API_URL,\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// Add request interceptor to inject auth token\napi.interceptors.request.use(config => {\n  const token = getToken();\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n}, error => Promise.reject(error));\nexport const fetchChatMessages = async chatId => {\n  try {\n    const response = await api.get(`/messages/chat/${chatId}`);\n    if (!response.data || !Array.isArray(response.data)) {\n      throw new Error('Invalid response format from server');\n    }\n    return response.data;\n  } catch (error) {\n    console.error('Error fetching chat messages:', error);\n    if (axios.isAxiosError(error)) {\n      var _error$response, _error$response2, _error$response2$data;\n      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {\n        throw new Error('Authentication required');\n      }\n      throw new Error(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.detail) || 'Failed to fetch chat messages');\n    }\n    throw error;\n  }\n};\n\n// Helper function to group messages by chat session\nexport const groupMessagesByChat = messages => {\n  const groupedMessages = messages.reduce((acc, message) => {\n    const key = message.chat_id || message.id.toString();\n    if (!acc[key]) {\n      acc[key] = {\n        id: key,\n        messages: [],\n        timestamp: message.timestamp\n      };\n    }\n    acc[key].messages.push(message);\n    return acc;\n  }, {});\n  return Object.values(groupedMessages).sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n};\nexport const fetchCharacters = async () => {\n  try {\n    const response = await api.get('/characters');\n    return response.data;\n  } catch (error) {\n    console.error('Error fetching characters:', error);\n    throw new Error('Failed to fetch characters');\n  }\n};\nexport const sendMessage = async message => {\n  try {\n    const response = await api.post('/chat', message);\n    return response.data;\n  } catch (error) {\n    console.error('Error sending message:', error);\n    throw error;\n  }\n};\nexport const streamMessage = async (message, onMessage) => {\n  let retryCount = 0;\n  const MAX_RETRIES = 3;\n  const RETRY_DELAY = 1000;\n  let messageBuffer = '';\n  let lastChunkTime = Date.now();\n  const CHUNK_TIMEOUT = 10000;\n  const connect = () => {\n    const params = new URLSearchParams({\n      message: message.message,\n      ...(message.character_id && {\n        character_id: message.character_id.toString()\n      }),\n      ...(message.chat_id && {\n        chat_session: message.chat_id\n      })\n    });\n    const token = getToken();\n    if (!token) {\n      onMessage({\n        text: '',\n        done: true,\n        error: 'Authentication required'\n      });\n      return;\n    }\n\n    // Add token to URL params since EventSource doesn't support custom headers\n    params.append('token', token);\n    const eventSource = new EventSource(`${API_URL}/chat?${params.toString()}`, {\n      withCredentials: true\n    });\n    eventSource.onmessage = event => {\n      try {\n        var _data$text;\n        const data = JSON.parse(event.data);\n        lastChunkTime = Date.now();\n        if (data.error) {\n          console.error('Stream error:', data.error);\n          eventSource.close();\n          onMessage({\n            text: '',\n            done: true,\n            error: data.error\n          });\n          return;\n        }\n        if ((_data$text = data.text) !== null && _data$text !== void 0 && _data$text.trim()) {\n          messageBuffer += data.text;\n          onMessage({\n            text: data.text,\n            done: false\n          });\n        }\n        if (data.done) {\n          eventSource.close();\n          if (messageBuffer.trim()) {\n            onMessage({\n              text: '',\n              done: true\n            });\n          }\n        }\n      } catch (error) {\n        console.error('Error parsing message:', error);\n        eventSource.close();\n        onMessage({\n          text: '',\n          done: true,\n          error: 'Failed to parse response'\n        });\n      }\n    };\n    eventSource.onerror = async error => {\n      const currentTime = Date.now();\n      console.error('EventSource error:', error);\n      eventSource.close();\n      if (currentTime - lastChunkTime > CHUNK_TIMEOUT) {\n        onMessage({\n          text: '',\n          done: true,\n          error: 'Response timeout. Please try again.'\n        });\n        return;\n      }\n      if (retryCount < MAX_RETRIES) {\n        retryCount++;\n        console.log(`Retrying connection (${retryCount}/${MAX_RETRIES})...`);\n        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));\n        connect();\n      } else {\n        onMessage({\n          text: '',\n          done: true,\n          error: 'Connection failed after multiple attempts.'\n        });\n      }\n    };\n    return () => {\n      eventSource.close();\n    };\n  };\n  return connect();\n};\nexport const createCharacter = async character => {\n  try {\n    const response = await api.post('/characters', character);\n    return response.data;\n  } catch (error) {\n    console.error('Error creating character:', error);\n    throw error;\n  }\n};\nexport const updateCharacter = async (id, character) => {\n  try {\n    const response = await api.put(`/characters/${id}`, character);\n    return response.data;\n  } catch (error) {\n    console.error('Error updating character:', error);\n    throw error;\n  }\n};\nexport const deleteCharacter = async id => {\n  try {\n    await api.delete(`/characters/${id}`);\n  } catch (error) {\n    console.error('Error deleting character:', error);\n    throw error;\n  }\n};\nexport const getCharacters = async () => {\n  const response = await api.get('/characters');\n  return response.data;\n};\nexport const selectCharacter = async characterId => {\n  await api.post(`/characters/${characterId}/select`);\n};\nexport const fetchChatHistory = async (characterId, limit = 50, offset = 0) => {\n  try {\n    let url = `/messages?limit=${limit}&offset=${offset}`;\n    if (characterId) {\n      url += `&character_id=${characterId}`;\n    }\n    const response = await api.get(url);\n    return response.data;\n  } catch (error) {\n    console.error('Error fetching chat history:', error);\n    throw error;\n  }\n};\nexport const fetchChatSessions = async () => {\n  try {\n    const response = await api.get('/chat/sessions');\n    return response.data;\n  } catch (error) {\n    console.error('Error fetching chat sessions:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["axios","getToken","API_URL","process","env","REACT_APP_API_URL","api","create","baseURL","headers","interceptors","request","use","config","token","Authorization","error","Promise","reject","fetchChatMessages","chatId","response","get","data","Array","isArray","Error","console","isAxiosError","_error$response","_error$response2","_error$response2$data","status","detail","groupMessagesByChat","messages","groupedMessages","reduce","acc","message","key","chat_id","id","toString","timestamp","push","Object","values","sort","a","b","Date","getTime","fetchCharacters","sendMessage","post","streamMessage","onMessage","retryCount","MAX_RETRIES","RETRY_DELAY","messageBuffer","lastChunkTime","now","CHUNK_TIMEOUT","connect","params","URLSearchParams","character_id","chat_session","text","done","append","eventSource","EventSource","withCredentials","onmessage","event","_data$text","JSON","parse","close","trim","onerror","currentTime","log","resolve","setTimeout","createCharacter","character","updateCharacter","put","deleteCharacter","delete","getCharacters","selectCharacter","characterId","fetchChatHistory","limit","offset","url","fetchChatSessions"],"sources":["C:/Users/ajits/fastapi-react-chatbot/frontend/src/services/api.ts"],"sourcesContent":["import axios, { RawAxiosRequestHeaders } from 'axios';\nimport { getToken } from './auth';\n\nexport const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n\n// Create axios instance with default config\nconst api = axios.create({\n    baseURL: API_URL,\n    headers: {\n        'Content-Type': 'application/json'\n    }\n});\n\n// Add request interceptor to inject auth token\napi.interceptors.request.use(\n    (config) => {\n        const token = getToken();\n        if (token) {\n            config.headers.Authorization = `Bearer ${token}`;\n        }\n        return config;\n    },\n    (error) => Promise.reject(error)\n);\n\nexport interface ChatMessage {\n    message: string;\n    character_id?: number;\n    user_id?: number;\n    chat_id?: string;\n    chat_session?: string;\n    timestamp: string;\n}\n\nexport interface ChatResponse {\n    response: string;\n}\n\nexport interface Character {\n    id: number;\n    name: string;\n    movie: string;\n    chat_style: string;\n    example_responses: string[];\n    created_at: string;\n    updated_at?: string;\n}\n\nexport interface StreamResponse {\n    text?: string;\n    done: boolean;\n    error?: string;\n    chat_session?: string;\n}\n\nexport interface ChatSession {\n    chat_session: string;\n    title: string;\n    last_message: string;\n    timestamp: string;\n    character_id?: number;\n}\n\nexport interface ChatHistoryMessage {\n    id: number;\n    message: string;\n    user_id: number;\n    character_id?: number;\n    is_bot: boolean;\n    timestamp: string;\n    last_message?: string; // Added this field\n    chat_id?: string;\n}\n\nexport interface GroupedChatMessage {\n    id: string;\n    messages: ChatHistoryMessage[];\n    timestamp: string;\n    character?: Character;\n}\n\nexport const fetchChatMessages = async (chatId: string): Promise<ChatHistoryMessage[]> => {\n    try {\n        const response = await api.get(`/messages/chat/${chatId}`);\n        if (!response.data || !Array.isArray(response.data)) {\n            throw new Error('Invalid response format from server');\n        }\n        return response.data;\n    } catch (error) {\n        console.error('Error fetching chat messages:', error);\n        if (axios.isAxiosError(error)) {\n            if (error.response?.status === 401) {\n                throw new Error('Authentication required');\n            }\n            throw new Error(error.response?.data?.detail || 'Failed to fetch chat messages');\n        }\n        throw error;\n    }\n};\n\n// Helper function to group messages by chat session\nexport const groupMessagesByChat = (messages: ChatHistoryMessage[]): GroupedChatMessage[] => {\n    const groupedMessages = messages.reduce((acc, message) => {\n        const key = message.chat_id || message.id.toString();\n        if (!acc[key]) {\n            acc[key] = {\n                id: key,\n                messages: [],\n                timestamp: message.timestamp,\n            };\n        }\n        acc[key].messages.push(message);\n        return acc;\n    }, {} as Record<string, GroupedChatMessage>);\n\n    return Object.values(groupedMessages).sort(\n        (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n    );\n};\n\nexport const fetchCharacters = async (): Promise<Character[]> => {\n    try {\n        const response = await api.get('/characters');\n        return response.data;\n    } catch (error) {\n        console.error('Error fetching characters:', error);\n        throw new Error('Failed to fetch characters');\n    }\n};\n\nexport const sendMessage = async (message: ChatMessage): Promise<ChatResponse> => {\n    try {\n        const response = await api.post('/chat', message);\n        return response.data;\n    } catch (error) {\n        console.error('Error sending message:', error);\n        throw error;\n    }\n};\n\nexport const streamMessage = async (\n    message: ChatMessage,\n    onMessage: (data: StreamResponse) => void\n) => {\n    let retryCount = 0;\n    const MAX_RETRIES = 3;\n    const RETRY_DELAY = 1000;\n    let messageBuffer = '';\n    let lastChunkTime = Date.now();\n    const CHUNK_TIMEOUT = 10000;\n\n    const connect = () => {\n        const params = new URLSearchParams({\n            message: message.message,\n            ...(message.character_id && { character_id: message.character_id.toString() }),\n            ...(message.chat_id && { chat_session: message.chat_id })\n        });\n\n        const token = getToken();\n        if (!token) {\n            onMessage({ text: '', done: true, error: 'Authentication required' });\n            return;\n        }\n\n        // Add token to URL params since EventSource doesn't support custom headers\n        params.append('token', token);\n        \n        const eventSource = new EventSource(\n            `${API_URL}/chat?${params.toString()}`,\n            { withCredentials: true }\n        );\n\n        eventSource.onmessage = (event) => {\n            try {\n                const data = JSON.parse(event.data) as StreamResponse;\n                lastChunkTime = Date.now();\n                \n                if (data.error) {\n                    console.error('Stream error:', data.error);\n                    eventSource.close();\n                    onMessage({ text: '', done: true, error: data.error });\n                    return;\n                }\n\n                if (data.text?.trim()) {\n                    messageBuffer += data.text;\n                    onMessage({ text: data.text, done: false });\n                }\n                \n                if (data.done) {\n                    eventSource.close();\n                    if (messageBuffer.trim()) {\n                        onMessage({ text: '', done: true });\n                    }\n                }\n            } catch (error) {\n                console.error('Error parsing message:', error);\n                eventSource.close();\n                onMessage({ text: '', done: true, error: 'Failed to parse response' });\n            }\n        };\n\n        eventSource.onerror = async (error) => {\n            const currentTime = Date.now();\n            console.error('EventSource error:', error);\n            eventSource.close();\n            \n            if (currentTime - lastChunkTime > CHUNK_TIMEOUT) {\n                onMessage({ text: '', done: true, error: 'Response timeout. Please try again.' });\n                return;\n            }\n            \n            if (retryCount < MAX_RETRIES) {\n                retryCount++;\n                console.log(`Retrying connection (${retryCount}/${MAX_RETRIES})...`);\n                await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));\n                connect();\n            } else {\n                onMessage({ text: '', done: true, error: 'Connection failed after multiple attempts.' });\n            }\n        };\n\n        return () => {\n            eventSource.close();\n        };\n    };\n\n    return connect();\n};\n\nexport const createCharacter = async (character: Omit<Character, 'id' | 'created_at' | 'updated_at'>): Promise<Character> => {\n    try {\n        const response = await api.post('/characters', character);\n        return response.data;\n    } catch (error) {\n        console.error('Error creating character:', error);\n        throw error;\n    }\n};\n\nexport const updateCharacter = async (id: number, character: Partial<Character>): Promise<Character> => {\n    try {\n        const response = await api.put(`/characters/${id}`, character);\n        return response.data;\n    } catch (error) {\n        console.error('Error updating character:', error);\n        throw error;\n    }\n};\n\nexport const deleteCharacter = async (id: number): Promise<void> => {\n    try {\n        await api.delete(`/characters/${id}`);\n    } catch (error) {\n        console.error('Error deleting character:', error);\n        throw error;\n    }\n};\n\nexport const getCharacters = async (): Promise<Character[]> => {\n    const response = await api.get('/characters');\n    return response.data;\n};\n\nexport const selectCharacter = async (characterId: number): Promise<void> => {\n    await api.post(`/characters/${characterId}/select`);\n};\n\nexport const fetchChatHistory = async (\n    characterId?: number,\n    limit: number = 50,\n    offset: number = 0\n): Promise<ChatHistoryMessage[]> => {\n    try {\n        let url = `/messages?limit=${limit}&offset=${offset}`;\n        if (characterId) {\n            url += `&character_id=${characterId}`;\n        }\n        const response = await api.get(url);\n        return response.data;\n    } catch (error) {\n        console.error('Error fetching chat history:', error);\n        throw error;\n    }\n};\n\nexport const fetchChatSessions = async (): Promise<ChatSession[]> => {\n    try {\n        const response = await api.get('/chat/sessions');\n        return response.data;\n    } catch (error) {\n        console.error('Error fetching chat sessions:', error);\n        throw error;\n    }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}