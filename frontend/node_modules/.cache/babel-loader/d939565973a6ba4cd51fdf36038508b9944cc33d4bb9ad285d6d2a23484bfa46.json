{"ast":null,"code":"import axios from'axios';export const API_URL=process.env.REACT_APP_API_URL||'http://localhost:8000';export const fetchChatMessages=async chatId=>{try{const userId=1;// TODO: Get from auth context\nconst response=await axios.get(`${API_URL}/messages/${userId}/${parseInt(chatId)}`);return response.data;}catch(error){console.error('Error fetching chat messages:',error);throw error;}};// Helper function to group messages by chat session\nexport const groupMessagesByChat=messages=>{const groupedMessages=messages.reduce((acc,message)=>{const key=message.chat_id||message.id.toString();if(!acc[key]){acc[key]={id:key,messages:[],timestamp:message.timestamp};}acc[key].messages.push(message);return acc;},{});return Object.values(groupedMessages).sort((a,b)=>new Date(b.timestamp).getTime()-new Date(a.timestamp).getTime());};export const fetchCharacters=async()=>{try{const response=await fetch(`${API_URL}/characters`);if(!response.ok){throw new Error(`HTTP error! status: ${response.status}`);}const data=await response.json();return data;}catch(error){console.error('Error fetching characters:',error);throw new Error('Failed to fetch characters');}};export const sendMessage=async message=>{try{const response=await axios.post(`${API_URL}/chat`,{...message,user_id:message.user_id||1// Default to user_id 1 if not provided\n});return response.data;}catch(error){console.error('Error sending message:',error);throw error;}};export const streamMessage=async(message,onMessage)=>{let retryCount=0;const MAX_RETRIES=3;const RETRY_DELAY=1000;let messageBuffer='';let lastChunkTime=Date.now();const CHUNK_TIMEOUT=10000;const connect=()=>{const params=new URLSearchParams({message:message.message,user_id:(message.user_id||1).toString(),...(message.character_id&&{character_id:message.character_id.toString()})});const eventSource=new EventSource(`${API_URL}/chat?${params}`);eventSource.onmessage=event=>{try{var _data$text;const data=JSON.parse(event.data);lastChunkTime=Date.now();if(data.error){console.error('Stream error:',data.error);eventSource.close();onMessage({text:'',done:true,error:data.error});return;}if((_data$text=data.text)!==null&&_data$text!==void 0&&_data$text.trim()){messageBuffer+=data.text;onMessage({text:data.text,done:false});}if(data.done){eventSource.close();if(messageBuffer.trim()){onMessage({text:'',done:true});}}}catch(error){console.error('Error parsing message:',error);eventSource.close();onMessage({text:'',done:true,error:'Failed to parse response'});}};eventSource.onerror=async error=>{const currentTime=Date.now();console.error('EventSource error:',error);eventSource.close();if(currentTime-lastChunkTime>CHUNK_TIMEOUT){onMessage({text:'',done:true,error:'Response timeout. Please try again.'});return;}if(retryCount<MAX_RETRIES){retryCount++;console.log(`Retrying connection (${retryCount}/${MAX_RETRIES})...`);await new Promise(resolve=>setTimeout(resolve,RETRY_DELAY));connect();}else{onMessage({text:'',done:true,error:'Connection failed after multiple attempts.'});}};return()=>{eventSource.close();};};return connect();};export const createCharacter=async character=>{try{const response=await fetch(`${API_URL}/characters`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(character)});if(!response.ok){const errorData=await response.json();throw new Error(errorData.detail||`HTTP error! status: ${response.status}`);}return await response.json();}catch(error){console.error('Error creating character:',error);throw error;}};export const updateCharacter=async(id,character)=>{try{const response=await fetch(`${API_URL}/characters/${id}`,{method:'PUT',headers:{'Content-Type':'application/json'},body:JSON.stringify(character)});if(!response.ok){const errorData=await response.json();throw new Error(errorData.detail||`HTTP error! status: ${response.status}`);}return await response.json();}catch(error){console.error('Error updating character:',error);throw error;}};export const deleteCharacter=async id=>{try{const response=await fetch(`${API_URL}/characters/${id}`,{method:'DELETE'});if(!response.ok){const errorData=await response.json();throw new Error(errorData.detail||`HTTP error! status: ${response.status}`);}}catch(error){console.error('Error deleting character:',error);throw error;}};export const getCharacters=async()=>{const response=await fetch(`${API_URL}/characters`,{headers:getAuthHeaders()});if(!response.ok)throw new Error('Failed to fetch characters');return response.json();};export const selectCharacter=async characterId=>{const response=await fetch(`${API_URL}/characters/${characterId}/select`,{method:'POST',headers:getAuthHeaders()});if(!response.ok)throw new Error('Failed to select character');};export const fetchChatHistory=async function(){let userId=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;let characterId=arguments.length>1?arguments[1]:undefined;let limit=arguments.length>2&&arguments[2]!==undefined?arguments[2]:50;let offset=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;try{let url=`${API_URL}/messages/${userId}?limit=${limit}&offset=${offset}`;if(characterId){url+=`&character_id=${characterId}`;}const response=await axios.get(url);return response.data;}catch(error){console.error('Error fetching chat history:',error);throw error;}};function getAuthHeaders(){// For now, return basic headers with content-type\n// TODO: Add actual authentication token when auth system is implemented\nreturn{'Content-Type':'application/json'};}","map":{"version":3,"names":["axios","API_URL","process","env","REACT_APP_API_URL","fetchChatMessages","chatId","userId","response","get","parseInt","data","error","console","groupMessagesByChat","messages","groupedMessages","reduce","acc","message","key","chat_id","id","toString","timestamp","push","Object","values","sort","a","b","Date","getTime","fetchCharacters","fetch","ok","Error","status","json","sendMessage","post","user_id","streamMessage","onMessage","retryCount","MAX_RETRIES","RETRY_DELAY","messageBuffer","lastChunkTime","now","CHUNK_TIMEOUT","connect","params","URLSearchParams","character_id","eventSource","EventSource","onmessage","event","_data$text","JSON","parse","close","text","done","trim","onerror","currentTime","log","Promise","resolve","setTimeout","createCharacter","character","method","headers","body","stringify","errorData","detail","updateCharacter","deleteCharacter","getCharacters","getAuthHeaders","selectCharacter","characterId","fetchChatHistory","arguments","length","undefined","limit","offset","url"],"sources":["C:/Users/ajits/fastapi-react-chatbot/frontend/src/services/api.ts"],"sourcesContent":["import axios from 'axios';\n\nexport const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n\nexport interface ChatMessage {\n    message: string;\n    character_id?: number;\n    user_id: number;\n    chat_id?: string;\n    timestamp: string;\n}\n\nexport interface ChatResponse {\n    response: string;\n}\n\nexport interface Character {\n    id: number;\n    name: string;\n    movie: string;\n    chat_style: string;\n    example_responses: string[];\n    created_at: string;\n    updated_at?: string;\n}\n\nexport interface StreamResponse {\n    text?: string;\n    done: boolean;\n    error?: string;\n}\n\nexport interface ChatHistoryMessage {\n    id: number;\n    message: string;\n    user_id: number;\n    character_id?: number;\n    is_bot: boolean;\n    timestamp: string;\n    last_message?: string; // Added this field\n    chat_id?: string;\n}\n\nexport interface GroupedChatMessage {\n    id: string;\n    messages: ChatHistoryMessage[];\n    timestamp: string;\n    character?: Character;\n}\n\nexport const fetchChatMessages = async (chatId: string): Promise<ChatHistoryMessage[]> => {\n    try {\n        const userId = 1; // TODO: Get from auth context\n        const response = await axios.get(`${API_URL}/messages/${userId}/${parseInt(chatId)}`);\n        return response.data;\n    } catch (error) {\n        console.error('Error fetching chat messages:', error);\n        throw error;\n    }\n};\n\n// Helper function to group messages by chat session\nexport const groupMessagesByChat = (messages: ChatHistoryMessage[]): GroupedChatMessage[] => {\n    const groupedMessages = messages.reduce((acc, message) => {\n        const key = message.chat_id || message.id.toString();\n        if (!acc[key]) {\n            acc[key] = {\n                id: key,\n                messages: [],\n                timestamp: message.timestamp,\n            };\n        }\n        acc[key].messages.push(message);\n        return acc;\n    }, {} as Record<string, GroupedChatMessage>);\n\n    return Object.values(groupedMessages).sort(\n        (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n    );\n};\n\nexport const fetchCharacters = async (): Promise<Character[]> => {\n    try {\n        const response = await fetch(`${API_URL}/characters`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error('Error fetching characters:', error);\n        throw new Error('Failed to fetch characters');\n    }\n};\n\nexport const sendMessage = async (message: ChatMessage): Promise<ChatResponse> => {\n    try {\n        const response = await axios.post(`${API_URL}/chat`, {\n            ...message,\n            user_id: message.user_id || 1  // Default to user_id 1 if not provided\n        });\n        return response.data;\n    } catch (error) {\n        console.error('Error sending message:', error);\n        throw error;\n    }\n};\n\nexport const streamMessage = async (\n    message: ChatMessage,\n    onMessage: (data: StreamResponse) => void\n) => {\n    let retryCount = 0;\n    const MAX_RETRIES = 3;\n    const RETRY_DELAY = 1000;\n    let messageBuffer = '';\n    let lastChunkTime = Date.now();\n    const CHUNK_TIMEOUT = 10000;\n\n    const connect = () => {\n        const params = new URLSearchParams({\n            message: message.message,\n            user_id: (message.user_id || 1).toString(),\n            ...(message.character_id && { character_id: message.character_id.toString() })\n        });\n\n        const eventSource = new EventSource(`${API_URL}/chat?${params}`);\n\n        eventSource.onmessage = (event) => {\n            try {\n                const data = JSON.parse(event.data) as StreamResponse;\n                lastChunkTime = Date.now();\n                \n                if (data.error) {\n                    console.error('Stream error:', data.error);\n                    eventSource.close();\n                    onMessage({ text: '', done: true, error: data.error });\n                    return;\n                }\n\n                if (data.text?.trim()) {\n                    messageBuffer += data.text;\n                    onMessage({ text: data.text, done: false });\n                }\n                \n                if (data.done) {\n                    eventSource.close();\n                    if (messageBuffer.trim()) {\n                        onMessage({ text: '', done: true });\n                    }\n                }\n            } catch (error) {\n                console.error('Error parsing message:', error);\n                eventSource.close();\n                onMessage({ text: '', done: true, error: 'Failed to parse response' });\n            }\n        };\n\n        eventSource.onerror = async (error) => {\n            const currentTime = Date.now();\n            console.error('EventSource error:', error);\n            eventSource.close();\n            \n            if (currentTime - lastChunkTime > CHUNK_TIMEOUT) {\n                onMessage({ text: '', done: true, error: 'Response timeout. Please try again.' });\n                return;\n            }\n            \n            if (retryCount < MAX_RETRIES) {\n                retryCount++;\n                console.log(`Retrying connection (${retryCount}/${MAX_RETRIES})...`);\n                await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));\n                connect();\n            } else {\n                onMessage({ text: '', done: true, error: 'Connection failed after multiple attempts.' });\n            }\n        };\n\n        return () => {\n            eventSource.close();\n        };\n    };\n\n    return connect();\n};\n\nexport const createCharacter = async (character: Omit<Character, 'id' | 'created_at' | 'updated_at'>): Promise<Character> => {\n    try {\n        const response = await fetch(`${API_URL}/characters`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(character),\n        });\n        \n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n        }\n        \n        return await response.json();\n    } catch (error) {\n        console.error('Error creating character:', error);\n        throw error;\n    }\n};\n\nexport const updateCharacter = async (id: number, character: Partial<Character>): Promise<Character> => {\n    try {\n        const response = await fetch(`${API_URL}/characters/${id}`, {\n            method: 'PUT',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(character),\n        });\n        \n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n        }\n        \n        return await response.json();\n    } catch (error) {\n        console.error('Error updating character:', error);\n        throw error;\n    }\n};\n\nexport const deleteCharacter = async (id: number): Promise<void> => {\n    try {\n        const response = await fetch(`${API_URL}/characters/${id}`, {\n            method: 'DELETE',\n        });\n        \n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n        }\n    } catch (error) {\n        console.error('Error deleting character:', error);\n        throw error;\n    }\n};\n\nexport const getCharacters = async (): Promise<Character[]> => {\n    const response = await fetch(`${API_URL}/characters`, {\n        headers: getAuthHeaders(),\n    });\n    if (!response.ok) throw new Error('Failed to fetch characters');\n    return response.json();\n};\n\nexport const selectCharacter = async (characterId: number): Promise<void> => {\n    const response = await fetch(`${API_URL}/characters/${characterId}/select`, {\n        method: 'POST',\n        headers: getAuthHeaders(),\n    });\n    if (!response.ok) throw new Error('Failed to select character');\n};\n\nexport const fetchChatHistory = async (\n    userId: number = 1,\n    characterId?: number,\n    limit: number = 50,\n    offset: number = 0\n): Promise<ChatHistoryMessage[]> => {\n    try {\n        let url = `${API_URL}/messages/${userId}?limit=${limit}&offset=${offset}`;\n        if (characterId) {\n            url += `&character_id=${characterId}`;\n        }\n        const response = await axios.get(url);\n        return response.data;\n    } catch (error) {\n        console.error('Error fetching chat history:', error);\n        throw error;\n    }\n};\n\nfunction getAuthHeaders(): HeadersInit {\n    // For now, return basic headers with content-type\n    // TODO: Add actual authentication token when auth system is implemented\n    return {\n        'Content-Type': 'application/json',\n    };\n}\n"],"mappings":"AAAA,MAAO,CAAAA,KAAK,KAAM,OAAO,CAEzB,MAAO,MAAM,CAAAC,OAAO,CAAGC,OAAO,CAACC,GAAG,CAACC,iBAAiB,EAAI,uBAAuB,CAgD/E,MAAO,MAAM,CAAAC,iBAAiB,CAAG,KAAO,CAAAC,MAAc,EAAoC,CACtF,GAAI,CACA,KAAM,CAAAC,MAAM,CAAG,CAAC,CAAE;AAClB,KAAM,CAAAC,QAAQ,CAAG,KAAM,CAAAR,KAAK,CAACS,GAAG,CAAC,GAAGR,OAAO,aAAaM,MAAM,IAAIG,QAAQ,CAACJ,MAAM,CAAC,EAAE,CAAC,CACrF,MAAO,CAAAE,QAAQ,CAACG,IAAI,CACxB,CAAE,MAAOC,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,+BAA+B,CAAEA,KAAK,CAAC,CACrD,KAAM,CAAAA,KAAK,CACf,CACJ,CAAC,CAED;AACA,MAAO,MAAM,CAAAE,mBAAmB,CAAIC,QAA8B,EAA2B,CACzF,KAAM,CAAAC,eAAe,CAAGD,QAAQ,CAACE,MAAM,CAAC,CAACC,GAAG,CAAEC,OAAO,GAAK,CACtD,KAAM,CAAAC,GAAG,CAAGD,OAAO,CAACE,OAAO,EAAIF,OAAO,CAACG,EAAE,CAACC,QAAQ,CAAC,CAAC,CACpD,GAAI,CAACL,GAAG,CAACE,GAAG,CAAC,CAAE,CACXF,GAAG,CAACE,GAAG,CAAC,CAAG,CACPE,EAAE,CAAEF,GAAG,CACPL,QAAQ,CAAE,EAAE,CACZS,SAAS,CAAEL,OAAO,CAACK,SACvB,CAAC,CACL,CACAN,GAAG,CAACE,GAAG,CAAC,CAACL,QAAQ,CAACU,IAAI,CAACN,OAAO,CAAC,CAC/B,MAAO,CAAAD,GAAG,CACd,CAAC,CAAE,CAAC,CAAuC,CAAC,CAE5C,MAAO,CAAAQ,MAAM,CAACC,MAAM,CAACX,eAAe,CAAC,CAACY,IAAI,CACtC,CAACC,CAAC,CAAEC,CAAC,GAAK,GAAI,CAAAC,IAAI,CAACD,CAAC,CAACN,SAAS,CAAC,CAACQ,OAAO,CAAC,CAAC,CAAG,GAAI,CAAAD,IAAI,CAACF,CAAC,CAACL,SAAS,CAAC,CAACQ,OAAO,CAAC,CAC9E,CAAC,CACL,CAAC,CAED,MAAO,MAAM,CAAAC,eAAe,CAAG,KAAAA,CAAA,GAAkC,CAC7D,GAAI,CACA,KAAM,CAAAzB,QAAQ,CAAG,KAAM,CAAA0B,KAAK,CAAC,GAAGjC,OAAO,aAAa,CAAC,CACrD,GAAI,CAACO,QAAQ,CAAC2B,EAAE,CAAE,CACd,KAAM,IAAI,CAAAC,KAAK,CAAC,uBAAuB5B,QAAQ,CAAC6B,MAAM,EAAE,CAAC,CAC7D,CACA,KAAM,CAAA1B,IAAI,CAAG,KAAM,CAAAH,QAAQ,CAAC8B,IAAI,CAAC,CAAC,CAClC,MAAO,CAAA3B,IAAI,CACf,CAAE,MAAOC,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,4BAA4B,CAAEA,KAAK,CAAC,CAClD,KAAM,IAAI,CAAAwB,KAAK,CAAC,4BAA4B,CAAC,CACjD,CACJ,CAAC,CAED,MAAO,MAAM,CAAAG,WAAW,CAAG,KAAO,CAAApB,OAAoB,EAA4B,CAC9E,GAAI,CACA,KAAM,CAAAX,QAAQ,CAAG,KAAM,CAAAR,KAAK,CAACwC,IAAI,CAAC,GAAGvC,OAAO,OAAO,CAAE,CACjD,GAAGkB,OAAO,CACVsB,OAAO,CAAEtB,OAAO,CAACsB,OAAO,EAAI,CAAG;AACnC,CAAC,CAAC,CACF,MAAO,CAAAjC,QAAQ,CAACG,IAAI,CACxB,CAAE,MAAOC,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,wBAAwB,CAAEA,KAAK,CAAC,CAC9C,KAAM,CAAAA,KAAK,CACf,CACJ,CAAC,CAED,MAAO,MAAM,CAAA8B,aAAa,CAAG,KAAAA,CACzBvB,OAAoB,CACpBwB,SAAyC,GACxC,CACD,GAAI,CAAAC,UAAU,CAAG,CAAC,CAClB,KAAM,CAAAC,WAAW,CAAG,CAAC,CACrB,KAAM,CAAAC,WAAW,CAAG,IAAI,CACxB,GAAI,CAAAC,aAAa,CAAG,EAAE,CACtB,GAAI,CAAAC,aAAa,CAAGjB,IAAI,CAACkB,GAAG,CAAC,CAAC,CAC9B,KAAM,CAAAC,aAAa,CAAG,KAAK,CAE3B,KAAM,CAAAC,OAAO,CAAGA,CAAA,GAAM,CAClB,KAAM,CAAAC,MAAM,CAAG,GAAI,CAAAC,eAAe,CAAC,CAC/BlC,OAAO,CAAEA,OAAO,CAACA,OAAO,CACxBsB,OAAO,CAAE,CAACtB,OAAO,CAACsB,OAAO,EAAI,CAAC,EAAElB,QAAQ,CAAC,CAAC,CAC1C,IAAIJ,OAAO,CAACmC,YAAY,EAAI,CAAEA,YAAY,CAAEnC,OAAO,CAACmC,YAAY,CAAC/B,QAAQ,CAAC,CAAE,CAAC,CACjF,CAAC,CAAC,CAEF,KAAM,CAAAgC,WAAW,CAAG,GAAI,CAAAC,WAAW,CAAC,GAAGvD,OAAO,SAASmD,MAAM,EAAE,CAAC,CAEhEG,WAAW,CAACE,SAAS,CAAIC,KAAK,EAAK,CAC/B,GAAI,KAAAC,UAAA,CACA,KAAM,CAAAhD,IAAI,CAAGiD,IAAI,CAACC,KAAK,CAACH,KAAK,CAAC/C,IAAI,CAAmB,CACrDqC,aAAa,CAAGjB,IAAI,CAACkB,GAAG,CAAC,CAAC,CAE1B,GAAItC,IAAI,CAACC,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,eAAe,CAAED,IAAI,CAACC,KAAK,CAAC,CAC1C2C,WAAW,CAACO,KAAK,CAAC,CAAC,CACnBnB,SAAS,CAAC,CAAEoB,IAAI,CAAE,EAAE,CAAEC,IAAI,CAAE,IAAI,CAAEpD,KAAK,CAAED,IAAI,CAACC,KAAM,CAAC,CAAC,CACtD,OACJ,CAEA,IAAA+C,UAAA,CAAIhD,IAAI,CAACoD,IAAI,UAAAJ,UAAA,WAATA,UAAA,CAAWM,IAAI,CAAC,CAAC,CAAE,CACnBlB,aAAa,EAAIpC,IAAI,CAACoD,IAAI,CAC1BpB,SAAS,CAAC,CAAEoB,IAAI,CAAEpD,IAAI,CAACoD,IAAI,CAAEC,IAAI,CAAE,KAAM,CAAC,CAAC,CAC/C,CAEA,GAAIrD,IAAI,CAACqD,IAAI,CAAE,CACXT,WAAW,CAACO,KAAK,CAAC,CAAC,CACnB,GAAIf,aAAa,CAACkB,IAAI,CAAC,CAAC,CAAE,CACtBtB,SAAS,CAAC,CAAEoB,IAAI,CAAE,EAAE,CAAEC,IAAI,CAAE,IAAK,CAAC,CAAC,CACvC,CACJ,CACJ,CAAE,MAAOpD,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,wBAAwB,CAAEA,KAAK,CAAC,CAC9C2C,WAAW,CAACO,KAAK,CAAC,CAAC,CACnBnB,SAAS,CAAC,CAAEoB,IAAI,CAAE,EAAE,CAAEC,IAAI,CAAE,IAAI,CAAEpD,KAAK,CAAE,0BAA2B,CAAC,CAAC,CAC1E,CACJ,CAAC,CAED2C,WAAW,CAACW,OAAO,CAAG,KAAO,CAAAtD,KAAK,EAAK,CACnC,KAAM,CAAAuD,WAAW,CAAGpC,IAAI,CAACkB,GAAG,CAAC,CAAC,CAC9BpC,OAAO,CAACD,KAAK,CAAC,oBAAoB,CAAEA,KAAK,CAAC,CAC1C2C,WAAW,CAACO,KAAK,CAAC,CAAC,CAEnB,GAAIK,WAAW,CAAGnB,aAAa,CAAGE,aAAa,CAAE,CAC7CP,SAAS,CAAC,CAAEoB,IAAI,CAAE,EAAE,CAAEC,IAAI,CAAE,IAAI,CAAEpD,KAAK,CAAE,qCAAsC,CAAC,CAAC,CACjF,OACJ,CAEA,GAAIgC,UAAU,CAAGC,WAAW,CAAE,CAC1BD,UAAU,EAAE,CACZ/B,OAAO,CAACuD,GAAG,CAAC,wBAAwBxB,UAAU,IAAIC,WAAW,MAAM,CAAC,CACpE,KAAM,IAAI,CAAAwB,OAAO,CAACC,OAAO,EAAIC,UAAU,CAACD,OAAO,CAAExB,WAAW,CAAC,CAAC,CAC9DK,OAAO,CAAC,CAAC,CACb,CAAC,IAAM,CACHR,SAAS,CAAC,CAAEoB,IAAI,CAAE,EAAE,CAAEC,IAAI,CAAE,IAAI,CAAEpD,KAAK,CAAE,4CAA6C,CAAC,CAAC,CAC5F,CACJ,CAAC,CAED,MAAO,IAAM,CACT2C,WAAW,CAACO,KAAK,CAAC,CAAC,CACvB,CAAC,CACL,CAAC,CAED,MAAO,CAAAX,OAAO,CAAC,CAAC,CACpB,CAAC,CAED,MAAO,MAAM,CAAAqB,eAAe,CAAG,KAAO,CAAAC,SAA8D,EAAyB,CACzH,GAAI,CACA,KAAM,CAAAjE,QAAQ,CAAG,KAAM,CAAA0B,KAAK,CAAC,GAAGjC,OAAO,aAAa,CAAE,CAClDyE,MAAM,CAAE,MAAM,CACdC,OAAO,CAAE,CACL,cAAc,CAAE,kBACpB,CAAC,CACDC,IAAI,CAAEhB,IAAI,CAACiB,SAAS,CAACJ,SAAS,CAClC,CAAC,CAAC,CAEF,GAAI,CAACjE,QAAQ,CAAC2B,EAAE,CAAE,CACd,KAAM,CAAA2C,SAAS,CAAG,KAAM,CAAAtE,QAAQ,CAAC8B,IAAI,CAAC,CAAC,CACvC,KAAM,IAAI,CAAAF,KAAK,CAAC0C,SAAS,CAACC,MAAM,EAAI,uBAAuBvE,QAAQ,CAAC6B,MAAM,EAAE,CAAC,CACjF,CAEA,MAAO,MAAM,CAAA7B,QAAQ,CAAC8B,IAAI,CAAC,CAAC,CAChC,CAAE,MAAO1B,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,2BAA2B,CAAEA,KAAK,CAAC,CACjD,KAAM,CAAAA,KAAK,CACf,CACJ,CAAC,CAED,MAAO,MAAM,CAAAoE,eAAe,CAAG,KAAAA,CAAO1D,EAAU,CAAEmD,SAA6B,GAAyB,CACpG,GAAI,CACA,KAAM,CAAAjE,QAAQ,CAAG,KAAM,CAAA0B,KAAK,CAAC,GAAGjC,OAAO,eAAeqB,EAAE,EAAE,CAAE,CACxDoD,MAAM,CAAE,KAAK,CACbC,OAAO,CAAE,CACL,cAAc,CAAE,kBACpB,CAAC,CACDC,IAAI,CAAEhB,IAAI,CAACiB,SAAS,CAACJ,SAAS,CAClC,CAAC,CAAC,CAEF,GAAI,CAACjE,QAAQ,CAAC2B,EAAE,CAAE,CACd,KAAM,CAAA2C,SAAS,CAAG,KAAM,CAAAtE,QAAQ,CAAC8B,IAAI,CAAC,CAAC,CACvC,KAAM,IAAI,CAAAF,KAAK,CAAC0C,SAAS,CAACC,MAAM,EAAI,uBAAuBvE,QAAQ,CAAC6B,MAAM,EAAE,CAAC,CACjF,CAEA,MAAO,MAAM,CAAA7B,QAAQ,CAAC8B,IAAI,CAAC,CAAC,CAChC,CAAE,MAAO1B,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,2BAA2B,CAAEA,KAAK,CAAC,CACjD,KAAM,CAAAA,KAAK,CACf,CACJ,CAAC,CAED,MAAO,MAAM,CAAAqE,eAAe,CAAG,KAAO,CAAA3D,EAAU,EAAoB,CAChE,GAAI,CACA,KAAM,CAAAd,QAAQ,CAAG,KAAM,CAAA0B,KAAK,CAAC,GAAGjC,OAAO,eAAeqB,EAAE,EAAE,CAAE,CACxDoD,MAAM,CAAE,QACZ,CAAC,CAAC,CAEF,GAAI,CAAClE,QAAQ,CAAC2B,EAAE,CAAE,CACd,KAAM,CAAA2C,SAAS,CAAG,KAAM,CAAAtE,QAAQ,CAAC8B,IAAI,CAAC,CAAC,CACvC,KAAM,IAAI,CAAAF,KAAK,CAAC0C,SAAS,CAACC,MAAM,EAAI,uBAAuBvE,QAAQ,CAAC6B,MAAM,EAAE,CAAC,CACjF,CACJ,CAAE,MAAOzB,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,2BAA2B,CAAEA,KAAK,CAAC,CACjD,KAAM,CAAAA,KAAK,CACf,CACJ,CAAC,CAED,MAAO,MAAM,CAAAsE,aAAa,CAAG,KAAAA,CAAA,GAAkC,CAC3D,KAAM,CAAA1E,QAAQ,CAAG,KAAM,CAAA0B,KAAK,CAAC,GAAGjC,OAAO,aAAa,CAAE,CAClD0E,OAAO,CAAEQ,cAAc,CAAC,CAC5B,CAAC,CAAC,CACF,GAAI,CAAC3E,QAAQ,CAAC2B,EAAE,CAAE,KAAM,IAAI,CAAAC,KAAK,CAAC,4BAA4B,CAAC,CAC/D,MAAO,CAAA5B,QAAQ,CAAC8B,IAAI,CAAC,CAAC,CAC1B,CAAC,CAED,MAAO,MAAM,CAAA8C,eAAe,CAAG,KAAO,CAAAC,WAAmB,EAAoB,CACzE,KAAM,CAAA7E,QAAQ,CAAG,KAAM,CAAA0B,KAAK,CAAC,GAAGjC,OAAO,eAAeoF,WAAW,SAAS,CAAE,CACxEX,MAAM,CAAE,MAAM,CACdC,OAAO,CAAEQ,cAAc,CAAC,CAC5B,CAAC,CAAC,CACF,GAAI,CAAC3E,QAAQ,CAAC2B,EAAE,CAAE,KAAM,IAAI,CAAAC,KAAK,CAAC,4BAA4B,CAAC,CACnE,CAAC,CAED,MAAO,MAAM,CAAAkD,gBAAgB,CAAG,cAAAA,CAAA,CAKI,IAJhC,CAAA/E,MAAc,CAAAgF,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,IAClB,CAAAF,WAAoB,CAAAE,SAAA,CAAAC,MAAA,GAAAD,SAAA,IAAAE,SAAA,IACpB,CAAAC,KAAa,CAAAH,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,EAAE,IAClB,CAAAI,MAAc,CAAAJ,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,CAElB,GAAI,CACA,GAAI,CAAAK,GAAG,CAAG,GAAG3F,OAAO,aAAaM,MAAM,UAAUmF,KAAK,WAAWC,MAAM,EAAE,CACzE,GAAIN,WAAW,CAAE,CACbO,GAAG,EAAI,iBAAiBP,WAAW,EAAE,CACzC,CACA,KAAM,CAAA7E,QAAQ,CAAG,KAAM,CAAAR,KAAK,CAACS,GAAG,CAACmF,GAAG,CAAC,CACrC,MAAO,CAAApF,QAAQ,CAACG,IAAI,CACxB,CAAE,MAAOC,KAAK,CAAE,CACZC,OAAO,CAACD,KAAK,CAAC,8BAA8B,CAAEA,KAAK,CAAC,CACpD,KAAM,CAAAA,KAAK,CACf,CACJ,CAAC,CAED,QAAS,CAAAuE,cAAcA,CAAA,CAAgB,CACnC;AACA;AACA,MAAO,CACH,cAAc,CAAE,kBACpB,CAAC,CACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}