{"ast":null,"code":"import{useState,useEffect,useCallback}from'react';export const useSpeech=function(){let{onSpeechResult,onSpeechStart,onSpeechEnd}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const[isListening,setIsListening]=useState(false);const[isSpeaking,setIsSpeaking]=useState(false);const[speechError,setSpeechError]=useState(null);// Initialize speech recognition\nconst recognition=useCallback(()=>{if('webkitSpeechRecognition'in window){const recognition=new window.webkitSpeechRecognition();recognition.continuous=false;recognition.interimResults=false;recognition.lang='en-US';return recognition;}return null;},[]);// Initialize speech synthesis\nconst synth=typeof window!=='undefined'?window.speechSynthesis:null;const startListening=useCallback(()=>{const recognitionInstance=recognition();if(!recognitionInstance){setSpeechError('Speech recognition is not supported in your browser');return;}try{setIsListening(true);setSpeechError(null);onSpeechStart===null||onSpeechStart===void 0?void 0:onSpeechStart();recognitionInstance.onresult=event=>{const transcript=event.results[0][0].transcript;onSpeechResult===null||onSpeechResult===void 0?void 0:onSpeechResult(transcript);};recognitionInstance.onerror=event=>{setSpeechError(event.error);setIsListening(false);};recognitionInstance.onend=()=>{setIsListening(false);onSpeechEnd===null||onSpeechEnd===void 0?void 0:onSpeechEnd();};recognitionInstance.start();}catch(error){setSpeechError('Error starting speech recognition');setIsListening(false);}},[recognition,onSpeechResult,onSpeechStart,onSpeechEnd]);const stopListening=useCallback(()=>{const recognitionInstance=recognition();if(recognitionInstance){recognitionInstance.stop();setIsListening(false);}},[recognition]);const speak=useCallback(text=>{if(!synth){setSpeechError('Speech synthesis is not supported in your browser');return;}// Cancel any ongoing speech\nsynth.cancel();const utterance=new SpeechSynthesisUtterance(text);utterance.rate=1.0;utterance.pitch=1.0;utterance.volume=1.0;utterance.onstart=()=>setIsSpeaking(true);utterance.onend=()=>setIsSpeaking(false);utterance.onerror=()=>{setIsSpeaking(false);setSpeechError('Error during speech synthesis');};synth.speak(utterance);},[synth]);// Cleanup on unmount\nuseEffect(()=>{return()=>{if(synth){synth.cancel();}const recognitionInstance=recognition();if(recognitionInstance){recognitionInstance.abort();}};},[recognition,synth]);return{startListening,stopListening,speak,isListening,isSpeaking,error:speechError};};","map":{"version":3,"names":["useState","useEffect","useCallback","useSpeech","onSpeechResult","onSpeechStart","onSpeechEnd","arguments","length","undefined","isListening","setIsListening","isSpeaking","setIsSpeaking","speechError","setSpeechError","recognition","window","webkitSpeechRecognition","continuous","interimResults","lang","synth","speechSynthesis","startListening","recognitionInstance","onresult","event","transcript","results","onerror","error","onend","start","stopListening","stop","speak","text","cancel","utterance","SpeechSynthesisUtterance","rate","pitch","volume","onstart","abort"],"sources":["C:/Users/ajits/fastapi-react-chatbot/frontend/src/hooks/useSpeech.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\r\n\r\ninterface UseSpeechProps {\r\n    onSpeechResult?: (text: string) => void;\r\n    onSpeechStart?: () => void;\r\n    onSpeechEnd?: () => void;\r\n}\r\n\r\nexport const useSpeech = ({ onSpeechResult, onSpeechStart, onSpeechEnd }: UseSpeechProps = {}) => {\r\n    const [isListening, setIsListening] = useState(false);\r\n    const [isSpeaking, setIsSpeaking] = useState(false);\r\n    const [speechError, setSpeechError] = useState<string | null>(null);\r\n\r\n    // Initialize speech recognition\r\n    const recognition = useCallback(() => {\r\n        if ('webkitSpeechRecognition' in window) {\r\n            const recognition = new (window as any).webkitSpeechRecognition();\r\n            recognition.continuous = false;\r\n            recognition.interimResults = false;\r\n            recognition.lang = 'en-US';\r\n            return recognition;\r\n        }\r\n        return null;\r\n    }, []);\r\n\r\n    // Initialize speech synthesis\r\n    const synth = typeof window !== 'undefined' ? window.speechSynthesis : null;\r\n\r\n    const startListening = useCallback(() => {\r\n        const recognitionInstance = recognition();\r\n        if (!recognitionInstance) {\r\n            setSpeechError('Speech recognition is not supported in your browser');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            setIsListening(true);\r\n            setSpeechError(null);\r\n            onSpeechStart?.();\r\n\r\n            recognitionInstance.onresult = (event: any) => {\r\n                const transcript = event.results[0][0].transcript;\r\n                onSpeechResult?.(transcript);\r\n            };\r\n\r\n            recognitionInstance.onerror = (event: any) => {\r\n                setSpeechError(event.error);\r\n                setIsListening(false);\r\n            };\r\n\r\n            recognitionInstance.onend = () => {\r\n                setIsListening(false);\r\n                onSpeechEnd?.();\r\n            };\r\n\r\n            recognitionInstance.start();\r\n        } catch (error) {\r\n            setSpeechError('Error starting speech recognition');\r\n            setIsListening(false);\r\n        }\r\n    }, [recognition, onSpeechResult, onSpeechStart, onSpeechEnd]);\r\n\r\n    const stopListening = useCallback(() => {\r\n        const recognitionInstance = recognition();\r\n        if (recognitionInstance) {\r\n            recognitionInstance.stop();\r\n            setIsListening(false);\r\n        }\r\n    }, [recognition]);\r\n\r\n    const speak = useCallback((text: string) => {\r\n        if (!synth) {\r\n            setSpeechError('Speech synthesis is not supported in your browser');\r\n            return;\r\n        }\r\n\r\n        // Cancel any ongoing speech\r\n        synth.cancel();\r\n\r\n        const utterance = new SpeechSynthesisUtterance(text);\r\n        utterance.rate = 1.0;\r\n        utterance.pitch = 1.0;\r\n        utterance.volume = 1.0;\r\n        \r\n        utterance.onstart = () => setIsSpeaking(true);\r\n        utterance.onend = () => setIsSpeaking(false);\r\n        utterance.onerror = () => {\r\n            setIsSpeaking(false);\r\n            setSpeechError('Error during speech synthesis');\r\n        };\r\n\r\n        synth.speak(utterance);\r\n    }, [synth]);\r\n\r\n    // Cleanup on unmount\r\n    useEffect(() => {\r\n        return () => {\r\n            if (synth) {\r\n                synth.cancel();\r\n            }\r\n            const recognitionInstance = recognition();\r\n            if (recognitionInstance) {\r\n                recognitionInstance.abort();\r\n            }\r\n        };\r\n    }, [recognition, synth]);\r\n\r\n    return {\r\n        startListening,\r\n        stopListening,\r\n        speak,\r\n        isListening,\r\n        isSpeaking,\r\n        error: speechError,\r\n    };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}