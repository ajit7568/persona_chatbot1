{"ast":null,"code":"import axios from 'axios';\nexport const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\nexport const fetchChatMessages = async chatId => {\n  try {\n    const userId = 1; // TODO: Get from auth context\n    const response = await axios.get(`${API_URL}/messages/${userId}/${chatId}`);\n    return response.data;\n  } catch (error) {\n    console.error('Error fetching chat messages:', error);\n    throw error;\n  }\n};\nexport const fetchCharacters = async () => {\n  try {\n    const response = await fetch(`${API_URL}/characters`);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error fetching characters:', error);\n    throw new Error('Failed to fetch characters');\n  }\n};\nexport const sendMessage = async message => {\n  try {\n    const response = await axios.post(`${API_URL}/chat`, {\n      ...message,\n      user_id: message.user_id || 1 // Default to user_id 1 if not provided\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error sending message:', error);\n    throw error;\n  }\n};\nexport const streamMessage = async (message, onMessage) => {\n  let retryCount = 0;\n  const MAX_RETRIES = 3;\n  const RETRY_DELAY = 1000;\n  let messageBuffer = '';\n  let lastChunkTime = Date.now();\n  const CHUNK_TIMEOUT = 10000;\n  const connect = () => {\n    const params = new URLSearchParams({\n      message: message.message,\n      user_id: (message.user_id || 1).toString(),\n      ...(message.character_id && {\n        character_id: message.character_id.toString()\n      })\n    });\n    const eventSource = new EventSource(`${API_URL}/chat?${params}`);\n    eventSource.onmessage = event => {\n      try {\n        var _data$text;\n        const data = JSON.parse(event.data);\n        lastChunkTime = Date.now();\n        if (data.error) {\n          console.error('Stream error:', data.error);\n          eventSource.close();\n          onMessage({\n            text: '',\n            done: true,\n            error: data.error\n          });\n          return;\n        }\n        if ((_data$text = data.text) !== null && _data$text !== void 0 && _data$text.trim()) {\n          messageBuffer += data.text;\n          onMessage({\n            text: data.text,\n            done: false\n          });\n        }\n        if (data.done) {\n          eventSource.close();\n          if (messageBuffer.trim()) {\n            onMessage({\n              text: '',\n              done: true\n            });\n          }\n        }\n      } catch (error) {\n        console.error('Error parsing message:', error);\n        eventSource.close();\n        onMessage({\n          text: '',\n          done: true,\n          error: 'Failed to parse response'\n        });\n      }\n    };\n    eventSource.onerror = async error => {\n      const currentTime = Date.now();\n      console.error('EventSource error:', error);\n      eventSource.close();\n      if (currentTime - lastChunkTime > CHUNK_TIMEOUT) {\n        onMessage({\n          text: '',\n          done: true,\n          error: 'Response timeout. Please try again.'\n        });\n        return;\n      }\n      if (retryCount < MAX_RETRIES) {\n        retryCount++;\n        console.log(`Retrying connection (${retryCount}/${MAX_RETRIES})...`);\n        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));\n        connect();\n      } else {\n        onMessage({\n          text: '',\n          done: true,\n          error: 'Connection failed after multiple attempts.'\n        });\n      }\n    };\n    return () => {\n      eventSource.close();\n    };\n  };\n  return connect();\n};\nexport const createCharacter = async character => {\n  try {\n    const response = await fetch(`${API_URL}/characters`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(character)\n    });\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Error creating character:', error);\n    throw error;\n  }\n};\nexport const updateCharacter = async (id, character) => {\n  try {\n    const response = await fetch(`${API_URL}/characters/${id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(character)\n    });\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Error updating character:', error);\n    throw error;\n  }\n};\nexport const deleteCharacter = async id => {\n  try {\n    const response = await fetch(`${API_URL}/characters/${id}`, {\n      method: 'DELETE'\n    });\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n    }\n  } catch (error) {\n    console.error('Error deleting character:', error);\n    throw error;\n  }\n};\nexport const getCharacters = async () => {\n  const response = await fetch(`${API_URL}/characters`, {\n    headers: getAuthHeaders()\n  });\n  if (!response.ok) throw new Error('Failed to fetch characters');\n  return response.json();\n};\nexport const selectCharacter = async characterId => {\n  const response = await fetch(`${API_URL}/characters/${characterId}/select`, {\n    method: 'POST',\n    headers: getAuthHeaders()\n  });\n  if (!response.ok) throw new Error('Failed to select character');\n};\nexport const fetchChatHistory = async (userId = 1, characterId, limit = 50, offset = 0) => {\n  try {\n    let url = `${API_URL}/chat/messages/${userId}?limit=${limit}&offset=${offset}`;\n    if (characterId) {\n      url += `&character_id=${characterId}`;\n    }\n    const response = await axios.get(url);\n    return response.data;\n  } catch (error) {\n    console.error('Error fetching chat history:', error);\n    throw error;\n  }\n};\nfunction getAuthHeaders() {\n  // For now, return basic headers with content-type\n  // TODO: Add actual authentication token when auth system is implemented\n  return {\n    'Content-Type': 'application/json'\n  };\n}","map":{"version":3,"names":["axios","API_URL","process","env","REACT_APP_API_URL","fetchChatMessages","chatId","userId","response","get","data","error","console","fetchCharacters","fetch","ok","Error","status","json","sendMessage","message","post","user_id","streamMessage","onMessage","retryCount","MAX_RETRIES","RETRY_DELAY","messageBuffer","lastChunkTime","Date","now","CHUNK_TIMEOUT","connect","params","URLSearchParams","toString","character_id","eventSource","EventSource","onmessage","event","_data$text","JSON","parse","close","text","done","trim","onerror","currentTime","log","Promise","resolve","setTimeout","createCharacter","character","method","headers","body","stringify","errorData","detail","updateCharacter","id","deleteCharacter","getCharacters","getAuthHeaders","selectCharacter","characterId","fetchChatHistory","limit","offset","url"],"sources":["C:/Users/ajits/fastapi-react-chatbot/frontend/src/services/api.ts"],"sourcesContent":["import axios from 'axios';\n\nexport const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';\n\nexport interface ChatMessage {\n    message: string;\n    character_id?: number;\n    user_id: number;\n}\n\nexport interface ChatResponse {\n    response: string;\n}\n\nexport interface Character {\n    id: number;\n    name: string;\n    movie: string;\n    chat_style: string;\n    example_responses: string[];\n    created_at: string;\n    updated_at?: string;\n}\n\nexport interface StreamResponse {\n    text?: string;\n    done: boolean;\n    error?: string;\n}\n\nexport interface ChatHistoryMessage {\n    id: number;\n    message: string;\n    user_id: number;\n    character_id?: number;\n    is_bot: boolean;\n    timestamp: string;\n    last_message?: string; // Added this field\n}\n\nexport const fetchChatMessages = async (chatId: string): Promise<ChatHistoryMessage[]> => {\n    try {\n        const userId = 1; // TODO: Get from auth context\n        const response = await axios.get(`${API_URL}/messages/${userId}/${chatId}`);\n        return response.data;\n    } catch (error) {\n        console.error('Error fetching chat messages:', error);\n        throw error;\n    }\n};\n\nexport const fetchCharacters = async (): Promise<Character[]> => {\n    try {\n        const response = await fetch(`${API_URL}/characters`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error('Error fetching characters:', error);\n        throw new Error('Failed to fetch characters');\n    }\n};\n\nexport const sendMessage = async (message: ChatMessage): Promise<ChatResponse> => {\n    try {\n        const response = await axios.post(`${API_URL}/chat`, {\n            ...message,\n            user_id: message.user_id || 1  // Default to user_id 1 if not provided\n        });\n        return response.data;\n    } catch (error) {\n        console.error('Error sending message:', error);\n        throw error;\n    }\n};\n\nexport const streamMessage = async (\n    message: ChatMessage,\n    onMessage: (data: StreamResponse) => void\n) => {\n    let retryCount = 0;\n    const MAX_RETRIES = 3;\n    const RETRY_DELAY = 1000;\n    let messageBuffer = '';\n    let lastChunkTime = Date.now();\n    const CHUNK_TIMEOUT = 10000;\n\n    const connect = () => {\n        const params = new URLSearchParams({\n            message: message.message,\n            user_id: (message.user_id || 1).toString(),\n            ...(message.character_id && { character_id: message.character_id.toString() })\n        });\n\n        const eventSource = new EventSource(`${API_URL}/chat?${params}`);\n\n        eventSource.onmessage = (event) => {\n            try {\n                const data = JSON.parse(event.data) as StreamResponse;\n                lastChunkTime = Date.now();\n                \n                if (data.error) {\n                    console.error('Stream error:', data.error);\n                    eventSource.close();\n                    onMessage({ text: '', done: true, error: data.error });\n                    return;\n                }\n\n                if (data.text?.trim()) {\n                    messageBuffer += data.text;\n                    onMessage({ text: data.text, done: false });\n                }\n                \n                if (data.done) {\n                    eventSource.close();\n                    if (messageBuffer.trim()) {\n                        onMessage({ text: '', done: true });\n                    }\n                }\n            } catch (error) {\n                console.error('Error parsing message:', error);\n                eventSource.close();\n                onMessage({ text: '', done: true, error: 'Failed to parse response' });\n            }\n        };\n\n        eventSource.onerror = async (error) => {\n            const currentTime = Date.now();\n            console.error('EventSource error:', error);\n            eventSource.close();\n            \n            if (currentTime - lastChunkTime > CHUNK_TIMEOUT) {\n                onMessage({ text: '', done: true, error: 'Response timeout. Please try again.' });\n                return;\n            }\n            \n            if (retryCount < MAX_RETRIES) {\n                retryCount++;\n                console.log(`Retrying connection (${retryCount}/${MAX_RETRIES})...`);\n                await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));\n                connect();\n            } else {\n                onMessage({ text: '', done: true, error: 'Connection failed after multiple attempts.' });\n            }\n        };\n\n        return () => {\n            eventSource.close();\n        };\n    };\n\n    return connect();\n};\n\nexport const createCharacter = async (character: Omit<Character, 'id' | 'created_at' | 'updated_at'>): Promise<Character> => {\n    try {\n        const response = await fetch(`${API_URL}/characters`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(character),\n        });\n        \n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n        }\n        \n        return await response.json();\n    } catch (error) {\n        console.error('Error creating character:', error);\n        throw error;\n    }\n};\n\nexport const updateCharacter = async (id: number, character: Partial<Character>): Promise<Character> => {\n    try {\n        const response = await fetch(`${API_URL}/characters/${id}`, {\n            method: 'PUT',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(character),\n        });\n        \n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n        }\n        \n        return await response.json();\n    } catch (error) {\n        console.error('Error updating character:', error);\n        throw error;\n    }\n};\n\nexport const deleteCharacter = async (id: number): Promise<void> => {\n    try {\n        const response = await fetch(`${API_URL}/characters/${id}`, {\n            method: 'DELETE',\n        });\n        \n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);\n        }\n    } catch (error) {\n        console.error('Error deleting character:', error);\n        throw error;\n    }\n};\n\nexport const getCharacters = async (): Promise<Character[]> => {\n    const response = await fetch(`${API_URL}/characters`, {\n        headers: getAuthHeaders(),\n    });\n    if (!response.ok) throw new Error('Failed to fetch characters');\n    return response.json();\n};\n\nexport const selectCharacter = async (characterId: number): Promise<void> => {\n    const response = await fetch(`${API_URL}/characters/${characterId}/select`, {\n        method: 'POST',\n        headers: getAuthHeaders(),\n    });\n    if (!response.ok) throw new Error('Failed to select character');\n};\n\nexport const fetchChatHistory = async (\n    userId: number = 1, // Default to user 1 for now\n    characterId?: number,\n    limit: number = 50,\n    offset: number = 0\n): Promise<ChatHistoryMessage[]> => {\n    try {\n        let url = `${API_URL}/chat/messages/${userId}?limit=${limit}&offset=${offset}`;\n        if (characterId) {\n            url += `&character_id=${characterId}`;\n        }\n        const response = await axios.get(url);\n        return response.data;\n    } catch (error) {\n        console.error('Error fetching chat history:', error);\n        throw error;\n    }\n};\n\nfunction getAuthHeaders(): HeadersInit {\n    // For now, return basic headers with content-type\n    // TODO: Add actual authentication token when auth system is implemented\n    return {\n        'Content-Type': 'application/json',\n    };\n}\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AAEzB,OAAO,MAAMC,OAAO,GAAGC,OAAO,CAACC,GAAG,CAACC,iBAAiB,IAAI,uBAAuB;AAsC/E,OAAO,MAAMC,iBAAiB,GAAG,MAAOC,MAAc,IAAoC;EACtF,IAAI;IACA,MAAMC,MAAM,GAAG,CAAC,CAAC,CAAC;IAClB,MAAMC,QAAQ,GAAG,MAAMR,KAAK,CAACS,GAAG,CAAC,GAAGR,OAAO,aAAaM,MAAM,IAAID,MAAM,EAAE,CAAC;IAC3E,OAAOE,QAAQ,CAACE,IAAI;EACxB,CAAC,CAAC,OAAOC,KAAK,EAAE;IACZC,OAAO,CAACD,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;IACrD,MAAMA,KAAK;EACf;AACJ,CAAC;AAED,OAAO,MAAME,eAAe,GAAG,MAAAA,CAAA,KAAkC;EAC7D,IAAI;IACA,MAAML,QAAQ,GAAG,MAAMM,KAAK,CAAC,GAAGb,OAAO,aAAa,CAAC;IACrD,IAAI,CAACO,QAAQ,CAACO,EAAE,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,uBAAuBR,QAAQ,CAACS,MAAM,EAAE,CAAC;IAC7D;IACA,MAAMP,IAAI,GAAG,MAAMF,QAAQ,CAACU,IAAI,CAAC,CAAC;IAClC,OAAOR,IAAI;EACf,CAAC,CAAC,OAAOC,KAAK,EAAE;IACZC,OAAO,CAACD,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;IAClD,MAAM,IAAIK,KAAK,CAAC,4BAA4B,CAAC;EACjD;AACJ,CAAC;AAED,OAAO,MAAMG,WAAW,GAAG,MAAOC,OAAoB,IAA4B;EAC9E,IAAI;IACA,MAAMZ,QAAQ,GAAG,MAAMR,KAAK,CAACqB,IAAI,CAAC,GAAGpB,OAAO,OAAO,EAAE;MACjD,GAAGmB,OAAO;MACVE,OAAO,EAAEF,OAAO,CAACE,OAAO,IAAI,CAAC,CAAE;IACnC,CAAC,CAAC;IACF,OAAOd,QAAQ,CAACE,IAAI;EACxB,CAAC,CAAC,OAAOC,KAAK,EAAE;IACZC,OAAO,CAACD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;IAC9C,MAAMA,KAAK;EACf;AACJ,CAAC;AAED,OAAO,MAAMY,aAAa,GAAG,MAAAA,CACzBH,OAAoB,EACpBI,SAAyC,KACxC;EACD,IAAIC,UAAU,GAAG,CAAC;EAClB,MAAMC,WAAW,GAAG,CAAC;EACrB,MAAMC,WAAW,GAAG,IAAI;EACxB,IAAIC,aAAa,GAAG,EAAE;EACtB,IAAIC,aAAa,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;EAC9B,MAAMC,aAAa,GAAG,KAAK;EAE3B,MAAMC,OAAO,GAAGA,CAAA,KAAM;IAClB,MAAMC,MAAM,GAAG,IAAIC,eAAe,CAAC;MAC/Bf,OAAO,EAAEA,OAAO,CAACA,OAAO;MACxBE,OAAO,EAAE,CAACF,OAAO,CAACE,OAAO,IAAI,CAAC,EAAEc,QAAQ,CAAC,CAAC;MAC1C,IAAIhB,OAAO,CAACiB,YAAY,IAAI;QAAEA,YAAY,EAAEjB,OAAO,CAACiB,YAAY,CAACD,QAAQ,CAAC;MAAE,CAAC;IACjF,CAAC,CAAC;IAEF,MAAME,WAAW,GAAG,IAAIC,WAAW,CAAC,GAAGtC,OAAO,SAASiC,MAAM,EAAE,CAAC;IAEhEI,WAAW,CAACE,SAAS,GAAIC,KAAK,IAAK;MAC/B,IAAI;QAAA,IAAAC,UAAA;QACA,MAAMhC,IAAI,GAAGiC,IAAI,CAACC,KAAK,CAACH,KAAK,CAAC/B,IAAI,CAAmB;QACrDmB,aAAa,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;QAE1B,IAAIrB,IAAI,CAACC,KAAK,EAAE;UACZC,OAAO,CAACD,KAAK,CAAC,eAAe,EAAED,IAAI,CAACC,KAAK,CAAC;UAC1C2B,WAAW,CAACO,KAAK,CAAC,CAAC;UACnBrB,SAAS,CAAC;YAAEsB,IAAI,EAAE,EAAE;YAAEC,IAAI,EAAE,IAAI;YAAEpC,KAAK,EAAED,IAAI,CAACC;UAAM,CAAC,CAAC;UACtD;QACJ;QAEA,KAAA+B,UAAA,GAAIhC,IAAI,CAACoC,IAAI,cAAAJ,UAAA,eAATA,UAAA,CAAWM,IAAI,CAAC,CAAC,EAAE;UACnBpB,aAAa,IAAIlB,IAAI,CAACoC,IAAI;UAC1BtB,SAAS,CAAC;YAAEsB,IAAI,EAAEpC,IAAI,CAACoC,IAAI;YAAEC,IAAI,EAAE;UAAM,CAAC,CAAC;QAC/C;QAEA,IAAIrC,IAAI,CAACqC,IAAI,EAAE;UACXT,WAAW,CAACO,KAAK,CAAC,CAAC;UACnB,IAAIjB,aAAa,CAACoB,IAAI,CAAC,CAAC,EAAE;YACtBxB,SAAS,CAAC;cAAEsB,IAAI,EAAE,EAAE;cAAEC,IAAI,EAAE;YAAK,CAAC,CAAC;UACvC;QACJ;MACJ,CAAC,CAAC,OAAOpC,KAAK,EAAE;QACZC,OAAO,CAACD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;QAC9C2B,WAAW,CAACO,KAAK,CAAC,CAAC;QACnBrB,SAAS,CAAC;UAAEsB,IAAI,EAAE,EAAE;UAAEC,IAAI,EAAE,IAAI;UAAEpC,KAAK,EAAE;QAA2B,CAAC,CAAC;MAC1E;IACJ,CAAC;IAED2B,WAAW,CAACW,OAAO,GAAG,MAAOtC,KAAK,IAAK;MACnC,MAAMuC,WAAW,GAAGpB,IAAI,CAACC,GAAG,CAAC,CAAC;MAC9BnB,OAAO,CAACD,KAAK,CAAC,oBAAoB,EAAEA,KAAK,CAAC;MAC1C2B,WAAW,CAACO,KAAK,CAAC,CAAC;MAEnB,IAAIK,WAAW,GAAGrB,aAAa,GAAGG,aAAa,EAAE;QAC7CR,SAAS,CAAC;UAAEsB,IAAI,EAAE,EAAE;UAAEC,IAAI,EAAE,IAAI;UAAEpC,KAAK,EAAE;QAAsC,CAAC,CAAC;QACjF;MACJ;MAEA,IAAIc,UAAU,GAAGC,WAAW,EAAE;QAC1BD,UAAU,EAAE;QACZb,OAAO,CAACuC,GAAG,CAAC,wBAAwB1B,UAAU,IAAIC,WAAW,MAAM,CAAC;QACpE,MAAM,IAAI0B,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE1B,WAAW,CAAC,CAAC;QAC9DM,OAAO,CAAC,CAAC;MACb,CAAC,MAAM;QACHT,SAAS,CAAC;UAAEsB,IAAI,EAAE,EAAE;UAAEC,IAAI,EAAE,IAAI;UAAEpC,KAAK,EAAE;QAA6C,CAAC,CAAC;MAC5F;IACJ,CAAC;IAED,OAAO,MAAM;MACT2B,WAAW,CAACO,KAAK,CAAC,CAAC;IACvB,CAAC;EACL,CAAC;EAED,OAAOZ,OAAO,CAAC,CAAC;AACpB,CAAC;AAED,OAAO,MAAMsB,eAAe,GAAG,MAAOC,SAA8D,IAAyB;EACzH,IAAI;IACA,MAAMhD,QAAQ,GAAG,MAAMM,KAAK,CAAC,GAAGb,OAAO,aAAa,EAAE;MAClDwD,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACL,cAAc,EAAE;MACpB,CAAC;MACDC,IAAI,EAAEhB,IAAI,CAACiB,SAAS,CAACJ,SAAS;IAClC,CAAC,CAAC;IAEF,IAAI,CAAChD,QAAQ,CAACO,EAAE,EAAE;MACd,MAAM8C,SAAS,GAAG,MAAMrD,QAAQ,CAACU,IAAI,CAAC,CAAC;MACvC,MAAM,IAAIF,KAAK,CAAC6C,SAAS,CAACC,MAAM,IAAI,uBAAuBtD,QAAQ,CAACS,MAAM,EAAE,CAAC;IACjF;IAEA,OAAO,MAAMT,QAAQ,CAACU,IAAI,CAAC,CAAC;EAChC,CAAC,CAAC,OAAOP,KAAK,EAAE;IACZC,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;IACjD,MAAMA,KAAK;EACf;AACJ,CAAC;AAED,OAAO,MAAMoD,eAAe,GAAG,MAAAA,CAAOC,EAAU,EAAER,SAA6B,KAAyB;EACpG,IAAI;IACA,MAAMhD,QAAQ,GAAG,MAAMM,KAAK,CAAC,GAAGb,OAAO,eAAe+D,EAAE,EAAE,EAAE;MACxDP,MAAM,EAAE,KAAK;MACbC,OAAO,EAAE;QACL,cAAc,EAAE;MACpB,CAAC;MACDC,IAAI,EAAEhB,IAAI,CAACiB,SAAS,CAACJ,SAAS;IAClC,CAAC,CAAC;IAEF,IAAI,CAAChD,QAAQ,CAACO,EAAE,EAAE;MACd,MAAM8C,SAAS,GAAG,MAAMrD,QAAQ,CAACU,IAAI,CAAC,CAAC;MACvC,MAAM,IAAIF,KAAK,CAAC6C,SAAS,CAACC,MAAM,IAAI,uBAAuBtD,QAAQ,CAACS,MAAM,EAAE,CAAC;IACjF;IAEA,OAAO,MAAMT,QAAQ,CAACU,IAAI,CAAC,CAAC;EAChC,CAAC,CAAC,OAAOP,KAAK,EAAE;IACZC,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;IACjD,MAAMA,KAAK;EACf;AACJ,CAAC;AAED,OAAO,MAAMsD,eAAe,GAAG,MAAOD,EAAU,IAAoB;EAChE,IAAI;IACA,MAAMxD,QAAQ,GAAG,MAAMM,KAAK,CAAC,GAAGb,OAAO,eAAe+D,EAAE,EAAE,EAAE;MACxDP,MAAM,EAAE;IACZ,CAAC,CAAC;IAEF,IAAI,CAACjD,QAAQ,CAACO,EAAE,EAAE;MACd,MAAM8C,SAAS,GAAG,MAAMrD,QAAQ,CAACU,IAAI,CAAC,CAAC;MACvC,MAAM,IAAIF,KAAK,CAAC6C,SAAS,CAACC,MAAM,IAAI,uBAAuBtD,QAAQ,CAACS,MAAM,EAAE,CAAC;IACjF;EACJ,CAAC,CAAC,OAAON,KAAK,EAAE;IACZC,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;IACjD,MAAMA,KAAK;EACf;AACJ,CAAC;AAED,OAAO,MAAMuD,aAAa,GAAG,MAAAA,CAAA,KAAkC;EAC3D,MAAM1D,QAAQ,GAAG,MAAMM,KAAK,CAAC,GAAGb,OAAO,aAAa,EAAE;IAClDyD,OAAO,EAAES,cAAc,CAAC;EAC5B,CAAC,CAAC;EACF,IAAI,CAAC3D,QAAQ,CAACO,EAAE,EAAE,MAAM,IAAIC,KAAK,CAAC,4BAA4B,CAAC;EAC/D,OAAOR,QAAQ,CAACU,IAAI,CAAC,CAAC;AAC1B,CAAC;AAED,OAAO,MAAMkD,eAAe,GAAG,MAAOC,WAAmB,IAAoB;EACzE,MAAM7D,QAAQ,GAAG,MAAMM,KAAK,CAAC,GAAGb,OAAO,eAAeoE,WAAW,SAAS,EAAE;IACxEZ,MAAM,EAAE,MAAM;IACdC,OAAO,EAAES,cAAc,CAAC;EAC5B,CAAC,CAAC;EACF,IAAI,CAAC3D,QAAQ,CAACO,EAAE,EAAE,MAAM,IAAIC,KAAK,CAAC,4BAA4B,CAAC;AACnE,CAAC;AAED,OAAO,MAAMsD,gBAAgB,GAAG,MAAAA,CAC5B/D,MAAc,GAAG,CAAC,EAClB8D,WAAoB,EACpBE,KAAa,GAAG,EAAE,EAClBC,MAAc,GAAG,CAAC,KACc;EAChC,IAAI;IACA,IAAIC,GAAG,GAAG,GAAGxE,OAAO,kBAAkBM,MAAM,UAAUgE,KAAK,WAAWC,MAAM,EAAE;IAC9E,IAAIH,WAAW,EAAE;MACbI,GAAG,IAAI,iBAAiBJ,WAAW,EAAE;IACzC;IACA,MAAM7D,QAAQ,GAAG,MAAMR,KAAK,CAACS,GAAG,CAACgE,GAAG,CAAC;IACrC,OAAOjE,QAAQ,CAACE,IAAI;EACxB,CAAC,CAAC,OAAOC,KAAK,EAAE;IACZC,OAAO,CAACD,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;IACpD,MAAMA,KAAK;EACf;AACJ,CAAC;AAED,SAASwD,cAAcA,CAAA,EAAgB;EACnC;EACA;EACA,OAAO;IACH,cAAc,EAAE;EACpB,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}